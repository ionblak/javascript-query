
============ Основы ============
1.Какие методы HTTP запросов вы знаете?
Ответ: GET,HEAD,POST,DELETE,PUT,PATCH,OPTIONS.

2.Какие  версии HTTP протокола вы знаете?
Ответ: HTTP 1.1 & HTTP 2.0.

3.Какие коды ответа HTTP вы знаете?
Ответ:200 ok, 201 create, 404 not found, 500 internal server error, 204 no content,
 401 unauthorized, 400 bad request,403 forbidden(нет разрешения на доступ к ресурсу).

4.Что такое Cross-Origin Resource Sharing? Как избавится от проблем с CORS?
Ответ: Это запрет на отправку HTTP запросов на бекенд со сторонего домена.
Перед вашим HTTP запросом браузер запросить  у бекенда доступ.
Если API приватный, то в заголовках будет указан:
Access-Control-Allow-Origin: "домен оригинального сайта"
Если API публичный, то в заголовках будет указан:
Access-Control-Allow-Origin: * -то есть доступ с любого домена. 
Для решения проблем с CORS нужно на прямую пообщатся с создателем бекенда
Чтобы он открыл доступ вашему домену к  серверу.

5. Что такое COOKIE?
Это текстовый файл который состоит из ключа=значения разделенные точкой с запятой
 и хранится на компьютаре пользователя.COOKIE добовляются к каждому запросу
 на сервер. У COOKIE есть время жизни. оно может продливатся .

6. Какой максимальный размер COOKIE?
Ответ: 4кб данных что давольно мало. 

7. Что означает деректива use-strict?
Ответ: "use-strict" - это  устоновка которая заставляет код обрабатыватся в строгом режиме.
Строгий режим был введён в ECMAScript 5
В строгом режиме:
-некоторые ошибки можно найти быстрее,
-более опасные и не полезные черты JS либо запрещены, либо приводят к ошибке.

8. Чем отличается JS во время работы на Front-end & back-end?
Ответ: ничем 

9. Что такое статическая и динамическая типизация?
Ответ: Проверка типа - это процесс проверки и применения ограничений типов.
Выполняется компилятором или интерпретатором во время компиляции или выполнения.
Статическая типизация - проверка на присвоениие типов происходит во время комприляциию.
Динамическая типизация - это процесс подтверждения типобезопасности программы во 
время ее выполнения.

10. Как клиент взаимодействует с сервером?
Ответ: по модели взаимодействия клиент-сервер. Они взаимодействуют между собой с помощью
различных сетевых протоколов: IP-протокол, HTTP,FTR и многие другие.
Клиент отправляет HTTP-запросы на сервер , на что сервер отправляет HTTP-ответы.
Взаимодействия сети на седьмом уровне!
Двухуровневая модель взаимодействия клиент-сервер:
          client--->server
Многоуровневая модель:
          client--->application server--->database server
                <---                  <----  

11.Что такое REST?
ОТвет:REST - это стиль бекенд архитектуры, основаный на наборе принципов, которые описывают
как сетевые ресурсы  определяются и адресуются. Каждая единица информации однозначно 
определяется глобальным идентификатором, таким как URL. Каждая URL в свою очередь имеет
 строго заданный формат.

 12. Обьясните понятие мутабельность/иммутабельность? Какие типы бывают
  мутабельными и наоборот?
  Ответ: ?????????????????     

13. Как искать ошибки в коде ? Используете ли вы дебагер?
  Ответ:??????????
 
14. Каких известных людей в мире JS вы знаете?
Ответ: IT-kamasutra, Минин,.....

===============JS CORE===============
15.Какие существуют типы данных в JS?
Ответ:String, number, boolean, null(ничего, пусто),symbol(для создания уникальных идентификаторов),
 object, undefined(значение не присвоено),???????bigint( для целых чисел произвольной длины)???

16.Как проверить является ли обьект массивом?
Ответ:Проверить на наличие свойства constructor.
const variable = [];
if (variable.constructor === Array).

17.Как проверить является ли число конечным?
Ответ: Number.isFinite(число)

18.Как проверить что переменная равна NaN?
Ответ:Для проверки нужно использовать Number.isNaN(переменная).Утверждает дейсвительно ли переменная
 равна NaN!! Возврвщает true или false.
19.Чем отличается поведение isNaN() от Number.isNaN()?
Ответ: Number.isNaN() проверяет равна ли переменная NaN.
isNaN() проверяет является ли переменая  не типом number.Работает не коректно с булями, null и пустой
строкой а также с строками: isNaN("37");      // false: "37" преобразуется в число 37 которое не NaN
                    isNaN("37.37");   // false: "37.37" преобразуется в число 37.37 которое не NaN
                    isNaN("");        // false: пустая строка преобразуется в 0 которое не NaN
                    isNaN(" ");       // false: строка с пробелом преобразуется в 0 которое не NaN
                    isNaN("37,5");    // true

20. Сравните ключевые слова var, let, const?
Ответ:Отличия между var & let :1.Область видимости: У var область видимости функции.
                                                    У let,const блочная область видимости {}.
                               2.Поднятие(всплытие) переменой:У var присваивается undefined
                                                              У let,const ошибка в консоле(ReferenceError)
  Значение переменной нельзя переназначить обьявленной через const , в отличии от let и var!

21.Что такое область видимости?
ответ: Это доступность переменных в определенном месте кода.Есть несколько областей видимости: глобальная,
блочная, eval и функции.
* Переменная обьявленая в глобальной области видимости доступна всем.Это и есть ее уязвимость. Ее могут
изменить в любом участке кода.
* Любая конструкция использующая фигурные скобки {} является блочной областью видимости
 для переменныхобьявленых через const, let!
* Scope chain (цепочка областей видимости) - области видимости образуют иерархию, так что 
 дочерние области имеют доступ к переменным из родительских областей, но не наоборот.
* Поднятие переменных (hoisting) - это механизм интерпретатора, который, до фазы исполнения кода,
 поднимает объявления переменных в начало области видимости (блочной или функции)
 в которой они были объявлены.

 Фаза компиляции, интерпретации или оценки (compile time, evaluation time) - подготовка
 перед исполнением кода, проверка валидности синтаксиса исходного кода.
Фаза исполнения (runtime) - скрипт начинает исполняться, выполняются инструкции
 вызовов функций и оценки выражений, происходит поиск необходимых идентификаторов
 в соответствующих областях видимости и тому подобное.

 22.Что такое деструктуризация?
 Ответ: деструктуризация - разделение сложной структуры на простые части.
 Используя синтаксис деструктуризации вы можете получить меньшие фрагменты из массивов и объектов.
 Синтаксис деструктуризации можно использовать для объявления или присвоение переменной.
 Вы также можете обрабатывать вложенные структуры с помощью вложенного синтаксиса деструктуризации.

 23.Для чего преднозначены методы  setTimeout() и  setInterval()?
 Ответ: Таймаут позволяет запускать функцию по истечении определенного времени.
 Интервалы — это более простой способ повторения кода снова и снова, с установленным промежутком 
 времени повторений.
 const timerId = setTimeout(callback, delay, arg1, arg2, ...);
 timetid - для остановки функции clearTimeout(timetid) или clearInterval(timetid)
 callback - функция которая выполнится по истечению времени(delay) или будет выполнятся каждый отрезок времени(delay)
  arg1, arg2, ... - дополнительные парметры.

24.Сравните подходы работы с асинхроным кодом :callbaks vs promises vs async/await.
Ответ: сравнение callbaks vs promises {
     * коллбеки это функции, обещания это обьекты.
     * колбеки передаются вкачестве аргументов из внешнего кода во внутренний. Обещания возврвщаются из
     внутреннего кода во внешний.
     * коллбеки обрабатывают успешное или не успешное завершения, обещания ничего не обрабатывают.
     * коллбеки могут обрабатывать несколько событий, обещания связаны только с одним событием.
     (от этого появляется проблема коллбек-хел) 
}