
============ Основы ============
1.Какие методы HTTP запросов вы знаете?
Ответ: GET,HEAD,POST,DELETE,PUT,PATCH,OPTIONS.

2.Какие  версии HTTP протокола вы знаете?
Ответ: HTTP 1.1 & HTTP 2.0.

3.Какие коды ответа HTTP вы знаете?
Ответ:200 ok, 201 create, 404 not found, 500 internal server error, 204 no content,
 401 unauthorized, 400 bad request,403 forbidden(нет разрешения на доступ к ресурсу).

4.Что такое Cross-Origin Resource Sharing? Как избавится от проблем с CORS?
Ответ: Это запрет на отправку HTTP запросов на бекенд со сторонего домена.
Перед вашим HTTP запросом браузер запросить  у бекенда доступ.
Если API приватный, то в заголовках будет указан:
Access-Control-Allow-Origin: "домен оригинального сайта"
Если API публичный, то в заголовках будет указан:
Access-Control-Allow-Origin: * -то есть доступ с любого домена. 
Для решения проблем с CORS нужно на прямую пообщатся с создателем бекенда
Чтобы он открыл доступ вашему домену к  серверу.

5. Что такое COOKIE?
Это текстовый файл который состоит из ключа=значения разделенные точкой с запятой
 и хранится на компьютаре пользователя.COOKIE добовляются к каждому запросу
 на сервер. У COOKIE есть время жизни. оно может продливатся .

6. Какой максимальный размер COOKIE?
Ответ: 4кб данных что давольно мало. 

7. Что означает деректива use-strict?
Ответ: "use-strict" - это  устоновка которая заставляет код обрабатыватся в строгом режиме.
Строгий режим был введён в ECMAScript 5
В строгом режиме:
-некоторые ошибки можно найти быстрее,
-более опасные и не полезные черты JS либо запрещены, либо приводят к ошибке.

8. Чем отличается JS во время работы на Front-end & back-end?
Ответ: ничем 

9. Что такое статическая и динамическая типизация?
Ответ: Проверка типа - это процесс проверки и применения ограничений типов.
Выполняется компилятором или интерпретатором во время компиляции или выполнения.
Статическая типизация - проверка на присвоениие типов происходит во время комприляциию.
Динамическая типизация - это процесс подтверждения типобезопасности программы во 
время ее выполнения.

10. Как клиент взаимодействует с сервером?
Ответ: по модели взаимодействия клиент-сервер. Они взаимодействуют между собой с помощью
различных сетевых протоколов: IP-протокол, HTTP,FTR и многие другие.
Клиент отправляет HTTP-запросы на сервер , на что сервер отправляет HTTP-ответы.
Взаимодействия сети на седьмом уровне!
Двухуровневая модель взаимодействия клиент-сервер:
          client--->server
Многоуровневая модель:
          client--->application server--->database server
                <---                  <----  

11.Что такое REST?
ОТвет:REST - это стиль бекенд архитектуры, основаный на наборе принципов, которые описывают
как сетевые ресурсы  определяются и адресуются. Каждая единица информации однозначно 
определяется глобальным идентификатором, таким как URL. Каждая URL в свою очередь имеет
 строго заданный формат.

 12. Обьясните понятие мутабельность/иммутабельность? Какие типы бывают
  мутабельными и наоборот?
  Ответ: ?????????????????     

13. Как искать ошибки в коде ? Используете ли вы дебагер?
  Ответ:??????????
 
14. Каких известных людей в мире JS вы знаете?
Ответ: IT-kamasutra, Минин,.....

===============JS CORE===============
15.Какие существуют типы данных в JS?
Ответ:String, number, boolean, null(ничего, пусто),symbol(для создания уникальных идентификаторов),
 object, undefined(значение не присвоено),???????bigint( для целых чисел произвольной длины)???

16.Как проверить является ли обьект массивом?
Ответ:Проверить на наличие свойства constructor.
const variable = [];
if (variable.constructor === Array).

17.Как проверить является ли число конечным?
Ответ: Number.isFinite(число)

18.Как проверить что переменная равна NaN?
Ответ:Для проверки нужно использовать Number.isNaN(переменная).Утверждает дейсвительно ли переменная
 равна NaN!! Возврвщает true или false.
19.Чем отличается поведение isNaN() от Number.isNaN()?
Ответ: Number.isNaN() проверяет равна ли переменная NaN.
isNaN() проверяет является ли переменая  не типом number.Работает не коректно с булями, null и пустой
строкой а также с строками: isNaN("37");      // false: "37" преобразуется в число 37 которое не NaN
                    isNaN("37.37");   // false: "37.37" преобразуется в число 37.37 которое не NaN
                    isNaN("");        // false: пустая строка преобразуется в 0 которое не NaN
                    isNaN(" ");       // false: строка с пробелом преобразуется в 0 которое не NaN
                    isNaN("37,5");    // true

20. Сравните ключевые слова var, let, const?
Ответ:Отличия между var & let :1.Область видимости: У var область видимости функции.
                                                    У let,const блочная область видимости {}.
                               2.Поднятие(всплытие) переменой:У var присваивается undefined
                                                              У let,const ошибка в консоле(ReferenceError)
  Значение переменной нельзя переназначить обьявленной через const , в отличии от let и var!

21.Что такое область видимости?
ответ: Это доступность переменных в определенном месте кода.Есть несколько областей видимости: глобальная,
блочная, eval и функции.
* Переменная обьявленая в глобальной области видимости доступна всем.Это и есть ее уязвимость. Ее могут
изменить в любом участке кода.
* Любая конструкция использующая фигурные скобки {} является блочной областью видимости
 для переменныхобьявленых через const, let!
* Scope chain (цепочка областей видимости) - области видимости образуют иерархию, так что 
 дочерние области имеют доступ к переменным из родительских областей, но не наоборот.
* Поднятие переменных (hoisting) - это механизм интерпретатора, который, до фазы исполнения кода,
 поднимает объявления переменных в начало области видимости (блочной или функции)
 в которой они были объявлены.

 Фаза компиляции, интерпретации или оценки (compile time, evaluation time) - подготовка
 перед исполнением кода, проверка валидности синтаксиса исходного кода.
Фаза исполнения (runtime) - скрипт начинает исполняться, выполняются инструкции
 вызовов функций и оценки выражений, происходит поиск необходимых идентификаторов
 в соответствующих областях видимости и тому подобное.

 22.Что такое деструктуризация?
 Ответ: деструктуризация - разделение сложной структуры на простые части.
 Используя синтаксис деструктуризации вы можете получить меньшие фрагменты из массивов и объектов.
 Синтаксис деструктуризации можно использовать для объявления или присвоение переменной.
 Вы также можете обрабатывать вложенные структуры с помощью вложенного синтаксиса деструктуризации.

 23.Для чего преднозначены методы  setTimeout() и  setInterval()?
 Ответ: Таймаут позволяет запускать функцию по истечении определенного времени.
 Интервалы — это более простой способ повторения кода снова и снова, с установленным промежутком 
 времени повторений.
 const timerId = setTimeout(callback, delay, arg1, arg2, ...);
 timetid - для остановки функции clearTimeout(timetid) или clearInterval(timetid)
 callback - функция которая выполнится по истечению времени(delay) или будет выполнятся каждый отрезок времени(delay)
  arg1, arg2, ... - дополнительные парметры.

24.Сравните подходы работы с асинхроным кодом :callbaks vs promises vs async/await.
Ответ: сравнение callbaks vs promises {
     * коллбеки это функции, обещания это обьекты.
     * колбеки передаются вкачестве аргументов из внешнего кода во внутренний. Обещания возврвщаются из
     внутреннего кода во внешний.
     * коллбеки обрабатывают успешное или не успешное завершения, обещания ничего не обрабатывают.
     * коллбеки могут обрабатывать несколько событий, обещания связаны только с одним событием.
     (от этого появляется проблема коллбек-хел) 
}
      сравнение async/await vs promises {
        async/await - возвращает промис.
        * Лаконичный и чистый код: код более короче
        * Обработка ошибок : ипользование try/catch
        * Проверка условий и выполнение асинхронных действий: через asinc меньше вложностей более читабелен.
        * Промежуточные значения : в asinc их меньше при вызове промис2() исходя из промиса1() .
        * Стек ошибок: в промисах в цепочках then плохо отлавливаются ошибки.
        * Отладка : удобно работать с дебагером в asinc    
}

25.Можно ли записать новые особенности/функции в прототип стандартных классов (Array, Object и т.д)?
Почему нет? В каких случаях это возможно? Как обезопасить себя если нужно расширить прототип?
Ответ:да у нас есть возможность записывать записывать в прототипы новые методы , но лучше этогоне делать 
т.к это может привести к канфликтам одинаковых методов по названию и одна библиотека перепишет метод другой
т.к прототипы глобальны.
Есть только одна причина изменение встроеных прототипов. Это создание полифилов -это эмуляция метода 
который существует в спецификации но еще не поддерживается движком.Чтоб обеспечить себя нужно добавить условие
на проверку есть ли такой метод в прототипе.

26.Назовите методы массивов и для чего они нужны?
Ответ: array.join(s) - склеивает массив по разделителю(s) в строку.
       array.split(s) -  превращает строку в массив по разделителю(s).
       array.indexOf(х)- возвращает индекс  элемента(х) или -1 если такого элемента нет.
       array.concat() - обьединение двух и более массивов. Возвращает новый массив.
       array.includes(x)- определяет содержит ли массив элемент(х), возвращает true || false.
       array.pop()-удоляет послений элемент массива.Возвращает удаленный элемент.
       array.push()-добовляет элемент в конец массива.Возвращает значение свойства length.
       array.shift()- удаляет элемент из начала массива и возвращает его (элемента) значение
       array.unshift()- добавляет элемент в начало массива
       array.slice(begin, end) - Копирует элементы от begin, до, но не ключая, end в новый массив 
       array.splice(position, num)- изменяет исходный массив и возвращает массив, содержащий удаленные элементы.
                    position — указывает позицию (индекс) первого элемента для удаления
                    num — определяет количество удаляемых элементов
      array.splice(position, 0, new_element_1, new_element_2, ...)-  вставить один или несколько элементов в
       массив, передав три или более аргумента методу splice, при этом второй аргумент должен быть равен нулю.
       в этом случае возвращается пустой массив.
      Замена элементов массива. Метод splice() также позволяет вставить новые элементы в массив при
       одновременном удалении существующих элементов.Для этого необходмо передать по крайней мере три аргумента:
       вторым — количество элементов для удаления, а третим — элементы для вставки. Количество удаляемых и
       добавляемых элементов может не совпадать

27. Какие переберающие методы массива вы знаете? В чем их разница?
Ответ: array.map()- не изменяет исходный массив.возвращает новую коллекцию.Длинна исходного ===длинна нового.
       array.forEach()-просто перебирает колекцию и ничего не возвращает. замена For().
       array.filter()-не изменяет исходный массив. возвращает новую коллекцию даже если один элемент в массиве.
       array.reduce()- Перебирает.Не изменяет.Возвращает что угодно.
                       array.reduce(сallback[(previousValue, currentItem, index, array)], initialValue)
       array.sort()-Отсортирует исходный массив.Возвращает новый массив.
       array.find()- Используется для поиска уникального элемента.Переберает. Не изменяет. Возвращает элемент.
                     Останавливает перебор когда найдет элемент.
       array.every(),array.some() - every - проверяет прошли ли все элементы массива условие в callback-функции.
                                    some - проверяет проходит хоть один элемент условиею
                                    оба метода возвращают true || false.

28.Как работают операторы присваевания/сравнения/строчные/арефметические/битовые и т.д?
Ответ: присваивания: x = y                               срвнения:   
                    x += y -присваивание с сложением               a > b
                    x -= y -присваивание с вычитанием              a < b
                    x *= y -присваивание с умножением              a <= b
                    x /= y -присваивание делением                  a >= b
                    x %= y - присваивание по модулю                a === b равно
                                                                   a !== b не равно
      строчный оператор конкатенации строк "+"  и "+="

29.Опишите преднозначение и принципы работы  с колекциями  Set & Map.
Ответ: Map  в отличии от Object в качестве ключа можно использовать любые типы данных. Даже 
(Object, NaN, ) у мепа довольно много разных методов которые упрощают работу с колекциями.
Set - обьект который хранит в себе только уникальные данные то есть они никогда не повторяются.
Элементы Set являются и ключами и значениями.
В структуре WeakMap ключами могут быть только обьекты! удобно работать с кешем и
 предотвращать утечки памяти.такойже принцип и у WeakSet.

 30.Что озночает глубокая(deep) и поверхнастная(shallow) копия обьекта? как зделать каждую из них?
 Ответ: Поверхностная копия обьекта осуществляется через Object.assign() или через деструктуирущего
 присваивания {...obj}.Поверхносно мы можем скопировать только свойства верхнего уровня,
 на вложенные обькты будет передоатся ссылка.Не копирует свойства из прототипа.
        Глубокая копия осуществляется через методы джейсона JSON.parse(JSON.stringify(mainObj))
Он копирует любые вложности, но проблема в том, что он не копирует методы обьекта
написанные пользователем(функции,свойство Symbol).
Для глубокого клонирования можно использовать метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.
 
 ============== Функции ==============

 31.Какая разница между декларативной функцией(function declaration) и 
 функциональным выражением(functoin expression)?
 Ответ: Функция обьявленная через function declaration создается интерпретатором
 до выполнения кода  поэтому их можно вызвать до обьявления.
 Примеры: декларативноя функциея   -  function declaration(){},
          функциональное выражение - const expression = function() {}

32.Что такое анонимная функция?
Ответ: Анонимная функция - функция без имени используется в колбеках, функциональных вырожениях
которое вызывается немедленно!

33.Расскажите про стралочные функции.В чем разница стелочных от обычных функций?
Ответ: Стрелочные функции имеют болле лаконичный  синтаксис. Как и функциональные выражения они
присваиваются переменным  или могут быть анонимными!Перед использованием стрелочной функции её 
необходимо создать заранееюСтрелочные функции не имеют своего this. В отличии от обычных 
функций, изменить значение this внутри стрелки после ее объявления нельзя.
Стрелочные функции не имеют своего this. В отличии от обычных функций, изменить 
значение this внутри стрелки после ее объявления нельзя.

34.Что такое и для чего используют IIFE(Immediately Invoked Function Expression)?
Ответ:Это паттерн.Немедленн вызываемое функциональное выражение.Хороша в создании облости видимости.
Любые переменные внутри IIFE не видимы для внешнего мира.
Они не только помогают организовывать и изображать ваш код в приятной и понятной манере, 
они также помогают сократить количество багов, избегая создания совершенно ненужных элементов 
глобальной области видимости.
const result = (function() {
    return "From IIFE";
}()); - может возвращать результат

35.Что такое hosting как он работает для переменных и функций?
Ответ:
 Поднятие переменных (hoisting) - это механизм интерпретатора, который, до фазы исполнения кода,
 поднимает объявления переменных в начало области видимости (блочной или функции)
 в которой они были объявлены. Хостинг поднимает функции обьявленными через function declaration!

36.Что такое замыкание(closure) и какие сценарии его использования?
Ответ: Замыкание это способ получения доступа и управления внешними переменными из функциии.
С помощью лексического окружения  функции и контекста выполнения её в стеке 
выполнения(это стек с принципом LIFO (Последний вошёл, первый вышел)).
    Сценарии Использования: В колбеках событий 
                           для определения публичных функций, которые имеют доступ
 к закрытым от пользователя (private) функциям и переменным. Такая манера программирования 
 называется модульное программирование.

 37.Как вы понимаие замыкание? что выведено в консоли?
 let f = function() {
  console.log(1); ------------будет выведено еденица
}

const execute = function(f) {
  setTimeout(f, 1000);
}

execute(f); // что выведет в консоль и почему

f = function() {
  console.log(2);
} 

38.Что такое рекурсия?
Ответ:Рекурсия это функция которая сама себя вызывает.Работает спомощью Call Stack.

39. Что озночает ключевое слово this?
Ответ:Это контекст выполнения. У всех функций есть локальная переменная this.Во время
выполнения функции в переменную this записывается ссылка на обьект, вконтексте которого
она вызывается. This нам нужен для доступа к методам и свойствам Обьекта который
вызывает функцию.
Значение контекста внутри функции определяется в момент её вызова.
В глобальной области видимости, если скрипт выполняется не в строгом режиме,
 this ссылается на объект window. В строгом режиме, значение this, в глобальной 
 области видимости, будет undefined.

 40.Что такое потеря контекста,когда происходит и как ее избежать?
 Ответ:Это ситуация когда this неожиданным оброзом указывает не на то что нам нужно.
 В основном это происходит в колбека события когда в колбеке есть еще функции которые 
 теряют this всвою очередь .
 Чтоб избежать можно записать this в переменную в фукции-родителе.
 и тогда использовать в функциях-детях  эту переменную.Или предать this параметром функции для 
 функций-детей.И третий вариант использовать функции-дети как стрелочные функции 
 т.к у них нет своего this они ссылаются на this  функции-родителя.

 41.Методы функции bind / call / apply - зачем и в чем разница?
 Ответ: Используются чтобы принудельно сказать, чему равен this.
 Методы  call и apply  работают одинаково они привязуют контекст и сразу вызывают функцию.
 разница только в пердоваемых дополнительных параметрах. В call через запятую.А в apply
 ввиде массива.
 Метод bind позволяет навсегда привязать контекс функции.Своим результатом он возвращает 
 новую функцию,внутри которой this будет иметь жестко заданое значение.
 не обязательно создовать новую функцию можно перезаписать старую.не вызывет функцию.

 ==============Front-end================

 42.Что такое DOM?(Обьектная модель документа)
 Ответ: Это межплатформенный, независимый от языка  интерфейс для работы с HTML-документом.
 Содежит набор свойств и методов позволяющий искать,создовать и удалять элементы, реагировать
 на действие пользователя и другое.DOM является отражением HTML-документа.
 Это древовидная структура, в которой каждый узел это JavaScript-объект со свойсвами и 
 методами, представляющий часть HTML-документа. Объекты могут управляться программно, и любые 
 изменения отражаются в документе.

 43.Сравните атрибуты подключения скрипта async і defer в HTML-документі?
 У async и defer есть кое-что общее: они не блокируют отрисовку страницы.
  Так что пользователь может просмотреть содержимое страницы и ознакомиться с ней сразу же.

Но есть и значимые различия:
async-- порядок загрузки( кто первый загрузится тот и сработает) Может загрузиться и 
выполниться до того, как страница полностью загрузится. Такое случается, если скрипты 
маленькие или хранятся в кеше, а документ достаточно большой.
defer--Порядок документа (как расположены в документе).Выполняется после того, 
как документ загружен и обработан (ждёт), непосредственно перед DOMContentLoaded.
 async--- хорош для независимых скриптов, например счётчиков и рекламы, 
относительный порядок выполнения которых не играет роли.
На практике defer используется для скриптов, которым требуется доступ ко всему 
DOM и/или важен их относительный порядок выполнения.

44.Яка різниця між властивостями HTML-елементів innerHTML і innerText?
innerHTML извлекает и устанавливает содержимое в формате HTML. 
innerText извлекает и устанавливает содержимое тега в виде простого текста т.е выполняет
автоматическое кодирование и декодирование текста.innerText- не показывает теги.

45.Опишіть процес спливання (bubbling) подій у DOM.
Основной принцип всплытия- принаступлении события обработчики сначала срабатуют на 
самом вложеном элементе,затем на его родителе , затем на родителе родителя и так до
конца цепочки вложенности.Всплывают почти все события, например события focus и blur
 не всплывают.

46.Як зупинити спливання (bubbling) події?
Остановить всплытие можно вызвав метод на объекте события. лучше их не остонавливать.
event.stopPropagation().

47.Як зупинити дефолтну обробку події?
Некоторые события автоматически вызывают действие браузера встроенное по 
умолчанию как реакция на определенный тип события: переход по ссылке, отправка формы и т.п
event.preventDefault()ю

48.Чому дорівнює this в обробнику подій (event handler)?
this будет ссылатся DOM-обьект этого элемента. Если оброботчиком яляется метод обьекта 
то нам нужно привязать его контекст через bind().

49.Що таке LocalStorage і SessionStorage? Який максимальний розмір LocalStorage?
sessionStorage — используется для добавления данных в хранилище сеансов, и данные 
этого хранилища будут доступны для любой страницы с того же сайта, открытого в 
этом окне, т.е. сессии, и как только окно будет закрыто, сеанс будет завершен, а 
хранилище сеансов очищено.
localStorage — хранилище, которое охватывает несколько окон и сохранятеся после 
текущего сеанса. В частности, веб-приложения могут сохранить пользовательские 
данные, такие как настройки профиля или содержимое корзины товаров на стороне клиента.
localStorage (локальное хранилище) — позволяет хранить данные без истечения срока 
действия в формате пар ключ:значение на компьютере пользователя и читать их, когда 
пользователь снова вернется на страницу.
доступно через интерфейс window.localStorage
максимальный размер зависит от настройки пользователя у когото он безграничен у когото 
10mb, 5mb, 2,5mb.

50.Як отримати висоту блоку? Його положення щодо меж документа?
Для того чтоб определить ширину и высоту документа используют свойства объекта типа DOMRect
у которого есть метод elem.getBoundingClientRect() , которая возвращает обьект со свойствами:
x/y – X/Y-координаты начала прямоугольника относительно окна,
width/height – ширина/высота прямоугольника (могут быть отрицательными).
Дополнительные, «зависимые», свойства:
top/bottom – Y-координата верхней/нижней границы прямоугольника,
left/right – X-координата левой/правой границы прямоугольника.

51.Що таке webpack?
Webpack — это сборщик JS-модулей, менеджер модульных зависимостей, который анализирует
 дерево зависимостей и создает один или несколько результирующих файлов, содержащих всю
 кодовую базу проекта. Выстраивает порядок подключения модулей, собирает, минифицирует,
 запаковывает и многое другое.

 52.Чим відрізняється dev-збірка від prod?
 В prod ветке все максимально сжато и минифицировано и готово к отправке на хостинг.
 Также отличается название конечного файла к нему добовляется contenthash.

 =============Верстка===========
 53.Що таке блокова модель CSS?
 В блочной модели любой элемент это прямоугольный контейнер, не зависимо от того как
  он визуально представлен на странице. У элемента есть область содержимого и необязательные
  поля, отступы и рамка (граница).

54.Які способи центрування блокового контенту по горизонталі та вертикалі знаєте?
* text-align:center  -- если Центрируемый элемент строчный (inline)
Центрируемый элемент блочный (block):
* margin-left: auto и  margin-right: auto
* display:flex - родителю,  align-items: center; justify-content: center;
*display: table; - родителю,
    display: table-cell; // дочерний – как ячейку      
    vertical-align: middle; // отцентрировали содержимое вертикально
* через    position: absolute;
через display: grid;

55.Які підходи у верстці вам відомі (float, flex, grid, etc)?
знаком со flex

56.Як зробити додаток responsive?
Использование  max-width как максимальной доступной ширины без брейк поинтов медиа запросов.

57.Які є принципи семантичної верстки?
Семантическая разметка - подход к созданию HTML-разметки основанный на использовании тегов
 в соответствии с их предназначением согласно спецификации и подходящими под тип размечаемого
 контента.

58.Навіщо потрібні префікси для деяких CSS-властивостей (-webkit-, -moz- тощо)?
Вендорные префиксы - это специальные приставки, используемые производителями (вендорами)
 браузеров для экспериментальных, еще не принятых в стандарт, или не полностью реализованных
 в браузере CSS-свойств и значений.Вручную прописывать их не нужно, для этого используются 
 специальные инструменты которые автоматизируют процесс, например SASS-комилятор с 
 дополнительными настройками. 

 59.Як спростити написання кросбраузерних стилів?
 использовать  Normalize.css
               валидаторы кода
               вендорные префиксы
               препроцессоры Sass , Less
тестируйте ваш сайт на нескольких браузерах.
Упрощайте код

60.Практичне завдання: прокоментувати та виправити приклад поганого CSS або HTML.*

61.Що таке CSS-препроцесори? З якими працювали? Що нового вони приносять у стандартний CSS?
надстройка расширяющая CSS-синтаксис, облегчающая написание, поддержку и рефакторинг кода
Sass
 *препроцессор позволяет писать стили в отдельных файлах, что повышает качество структуры 
 проекта и поиск стилей отдельных блоков.
 *Чистота кода - из-за того что стили пишутся в отдельных файлах и применяются вспомогательные
  конструкции для повторного использования кода, он становится чище.
  *Переменные
  *Вложеность
  * арефметические операции
  *Миксины 
  *Директива @extend используется для наследования (расширения) уже существующих стилей.