
============ Основы ============
1.Какие методы HTTP запросов вы знаете?
Ответ: GET,HEAD,POST,DELETE,PUT,PATCH,OPTIONS.

2.Какие  версии HTTP протокола вы знаете?
Ответ: HTTP 1.1 & HTTP 2.0.

3.Какие коды ответа HTTP вы знаете?
Ответ:200 ok, 201 create, 404 not found, 500 internal server error, 204 no content,
 401 unauthorized, 400 bad request,403 forbidden(нет разрешения на доступ к ресурсу).

4.Что такое Cross-Origin Resource Sharing? Как избавится от проблем с CORS?
Ответ: Это запрет на отправку HTTP запросов на бекенд со сторонего домена.
Перед вашим HTTP запросом браузер запросить  у бекенда доступ.
Если API приватный, то в заголовках будет указан:
Access-Control-Allow-Origin: "домен оригинального сайта"
Если API публичный, то в заголовках будет указан:
Access-Control-Allow-Origin: * -то есть доступ с любого домена. 
Для решения проблем с CORS нужно на прямую пообщатся с создателем бекенда
Чтобы он открыл доступ вашему домену к  серверу.

5. Что такое COOKIE?
Это текстовый файл который состоит из ключа=значения разделенные точкой с запятой
 и хранится на компьютаре пользователя.COOKIE добовляются к каждому запросу
 на сервер. У COOKIE есть время жизни. оно может продливатся .

6. Какой максимальный размер COOKIE?
Ответ: 4кб данных что давольно мало. 

7. Что означает деректива use-strict?
Ответ: "use-strict" - это  устоновка которая заставляет код обрабатыватся в строгом режиме.
Строгий режим был введён в ECMAScript 5
В строгом режиме:
-некоторые ошибки можно найти быстрее,
-более опасные и не полезные черты JS либо запрещены, либо приводят к ошибке.

8. Чем отличается JS во время работы на Front-end & back-end?
Ответ: ничем 

9. Что такое статическая и динамическая типизация?
Ответ: Проверка типа - это процесс проверки и применения ограничений типов.
Выполняется компилятором или интерпретатором во время компиляции или выполнения.
Статическая типизация - проверка на присвоениие типов происходит во время комприляциию.
Динамическая типизация - это процесс подтверждения типобезопасности программы во 
время ее выполнения.

10. Как клиент взаимодействует с сервером?
Ответ: по модели взаимодействия клиент-сервер. Они взаимодействуют между собой с помощью
различных сетевых протоколов: IP-протокол, HTTP,FTR и многие другие.
Клиент отправляет HTTP-запросы на сервер , на что сервер отправляет HTTP-ответы.
Взаимодействия сети на седьмом уровне!
Двухуровневая модель взаимодействия клиент-сервер:
          client--->server
Многоуровневая модель:
          client--->application server--->database server
                <---                  <----  

11.Что такое REST?
ОТвет:REST - это стиль бекенд архитектуры, основаный на наборе принципов, которые описывают
как сетевые ресурсы  определяются и адресуются. Каждая единица информации однозначно 
определяется глобальным идентификатором, таким как URL. Каждая URL в свою очередь имеет
 строго заданный формат.

 12. Обьясните понятие мутабельность/иммутабельность? Какие типы бывают
  мутабельными и наоборот?
  Ответ: ?????????????????     

13. Как искать ошибки в коде ? Используете ли вы дебагер?
  Ответ:??????????
 
14. Каких известных людей в мире JS вы знаете?
Ответ: IT-kamasutra, Минин,.....

===============JS CORE===============
15.Какие существуют типы данных в JS?
Ответ:String, number, boolean, null(ничего, пусто),symbol(для создания уникальных идентификаторов),
 object, undefined(значение не присвоено),???????bigint( для целых чисел произвольной длины)???

16.Как проверить является ли обьект массивом?
Ответ:Проверить на наличие свойства constructor.
const variable = [];
if (variable.constructor === Array).

17.Как проверить является ли число конечным?
Ответ: Number.isFinite(число)

18.Как проверить что переменная равна NaN?
Ответ:Для проверки нужно использовать Number.isNaN(переменная).Утверждает дейсвительно ли переменная
 равна NaN!! Возврвщает true или false.
19.Чем отличается поведение isNaN() от Number.isNaN()?
Ответ: Number.isNaN() проверяет равна ли переменная NaN.
isNaN() проверяет является ли переменая  не типом number.Работает не коректно с булями, null и пустой
строкой а также с строками: isNaN("37");      // false: "37" преобразуется в число 37 которое не NaN
                    isNaN("37.37");   // false: "37.37" преобразуется в число 37.37 которое не NaN
                    isNaN("");        // false: пустая строка преобразуется в 0 которое не NaN
                    isNaN(" ");       // false: строка с пробелом преобразуется в 0 которое не NaN
                    isNaN("37,5");    // true

20. Сравните ключевые слова var, let, const?
Ответ:Отличия между var & let :1.Область видимости: У var область видимости функции.
                                                    У let,const блочная область видимости {}.
                               2.Поднятие(всплытие) переменой:У var присваивается undefined
                                                              У let,const ошибка в консоле(ReferenceError)
  Значение переменной нельзя переназначить обьявленной через const , в отличии от let и var!

21.Что такое область видимости?
ответ: Это доступность переменных в определенном месте кода.Есть несколько областей видимости: глобальная,
блочная, eval и функции.
* Переменная обьявленая в глобальной области видимости доступна всем.Это и есть ее уязвимость. Ее могут
изменить в любом участке кода.
* Любая конструкция использующая фигурные скобки {} является блочной областью видимости
 для переменныхобьявленых через const, let!
* Scope chain (цепочка областей видимости) - области видимости образуют иерархию, так что 
 дочерние области имеют доступ к переменным из родительских областей, но не наоборот.
* Поднятие переменных (hoisting) - это механизм интерпретатора, который, до фазы исполнения кода,
 поднимает объявления переменных в начало области видимости (блочной или функции)
 в которой они были объявлены.

 Фаза компиляции, интерпретации или оценки (compile time, evaluation time) - подготовка
 перед исполнением кода, проверка валидности синтаксиса исходного кода.
Фаза исполнения (runtime) - скрипт начинает исполняться, выполняются инструкции
 вызовов функций и оценки выражений, происходит поиск необходимых идентификаторов
 в соответствующих областях видимости и тому подобное.

 22.Что такое деструктуризация?
 Ответ: деструктуризация - разделение сложной структуры на простые части.
 Используя синтаксис деструктуризации вы можете получить меньшие фрагменты из массивов и объектов.
 Синтаксис деструктуризации можно использовать для объявления или присвоение переменной.
 Вы также можете обрабатывать вложенные структуры с помощью вложенного синтаксиса деструктуризации.

 23.Для чего преднозначены методы  setTimeout() и  setInterval()?
 Ответ: Таймаут позволяет запускать функцию по истечении определенного времени.
 Интервалы — это более простой способ повторения кода снова и снова, с установленным промежутком 
 времени повторений.
 const timerId = setTimeout(callback, delay, arg1, arg2, ...);
 timetid - для остановки функции clearTimeout(timetid) или clearInterval(timetid)
 callback - функция которая выполнится по истечению времени(delay) или будет выполнятся каждый отрезок времени(delay)
  arg1, arg2, ... - дополнительные парметры.

24.Сравните подходы работы с асинхроным кодом :callbaks vs promises vs async/await.
Ответ: сравнение callbaks vs promises {
     * коллбеки это функции, обещания это обьекты.
     * колбеки передаются вкачестве аргументов из внешнего кода во внутренний. Обещания возврвщаются из
     внутреннего кода во внешний.
     * коллбеки обрабатывают успешное или не успешное завершения, обещания ничего не обрабатывают.
     * коллбеки могут обрабатывать несколько событий, обещания связаны только с одним событием.
     (от этого появляется проблема коллбек-хел) 
}
      сравнение async/await vs promises {
        async/await - возвращает промис.
        * Лаконичный и чистый код: код более короче
        * Обработка ошибок : ипользование try/catch
        * Проверка условий и выполнение асинхронных действий: через asinc меньше вложностей более читабелен.
        * Промежуточные значения : в asinc их меньше при вызове промис2() исходя из промиса1() .
        * Стек ошибок: в промисах в цепочках then плохо отлавливаются ошибки.
        * Отладка : удобно работать с дебагером в asinc    
}

25.Можно ли записать новые особенности/функции в прототип стандартных классов (Array, Object и т.д)?
Почему нет? В каких случаях это возможно? Как обезопасить себя если нужно расширить прототип?
Ответ:да у нас есть возможность записывать записывать в прототипы новые методы , но лучше этогоне делать 
т.к это может привести к канфликтам одинаковых методов по названию и одна библиотека перепишет метод другой
т.к прототипы глобальны.
Есть только одна причина изменение встроеных прототипов. Это создание полифилов -это эмуляция метода 
который существует в спецификации но еще не поддерживается движком.Чтоб обеспечить себя нужно добавить условие
на проверку есть ли такой метод в прототипе.

26.Назовите методы массивов и для чего они нужны?
Ответ: array.join(s) - склеивает массив по разделителю(s) в строку.
       array.split(s) -  превращает строку в массив по разделителю(s).
       array.indexOf(х)- возвращает индекс  элемента(х) или -1 если такого элемента нет.
       array.concat() - обьединение двух и более массивов. Возвращает новый массив.
       array.includes(x)- определяет содержит ли массив элемент(х), возвращает true || false.
       array.pop()-удоляет послений элемент массива.Возвращает удаленный элемент.
       array.push()-добовляет элемент в конец массива.Возвращает значение свойства length.
       array.shift()- удаляет элемент из начала массива и возвращает его (элемента) значение
       array.unshift()- добавляет элемент в начало массива
       array.slice(begin, end) - Копирует элементы от begin, до, но не ключая, end в новый массив 
       array.splice(position, num)- изменяет исходный массив и возвращает массив, содержащий удаленные элементы.
                    position — указывает позицию (индекс) первого элемента для удаления
                    num — определяет количество удаляемых элементов
      array.splice(position, 0, new_element_1, new_element_2, ...)-  вставить один или несколько элементов в
       массив, передав три или более аргумента методу splice, при этом второй аргумент должен быть равен нулю.
       в этом случае возвращается пустой массив.
      Замена элементов массива. Метод splice() также позволяет вставить новые элементы в массив при
       одновременном удалении существующих элементов.Для этого необходмо передать по крайней мере три аргумента:
       вторым — количество элементов для удаления, а третим — элементы для вставки. Количество удаляемых и
       добавляемых элементов может не совпадать

27. Какие переберающие методы массива вы знаете? В чем их разница?
Ответ: array.map()- не изменяет исходный массив.возвращает новую коллекцию.Длинна исходного ===длинна нового.
       array.forEach()-просто перебирает колекцию и ничего не возвращает. замена For().
       array.filter()-не изменяет исходный массив. возвращает новую коллекцию даже если один элемент в массиве.
       array.reduce()- Перебирает.Не изменяет.Возвращает что угодно.
                       array.reduce(сallback[(previousValue, currentItem, index, array)], initialValue)
       array.sort()-Отсортирует исходный массив.Возвращает новый массив.
       array.find()- Используется для поиска уникального элемента.Переберает. Не изменяет. Возвращает элемент.
                     Останавливает перебор когда найдет элемент.
       array.every(),array.some() - every - проверяет прошли ли все элементы массива условие в callback-функции.
                                    some - проверяет проходит хоть один элемент условиею
                                    оба метода возвращают true || false.

28.Как работают операторы присваевания/сравнения/строчные/арефметические/битовые и т.д?
Ответ: присваивания: x = y                               срвнения:   
                    x += y -присваивание с сложением               a > b
                    x -= y -присваивание с вычитанием              a < b
                    x *= y -присваивание с умножением              a <= b
                    x /= y -присваивание делением                  a >= b
                    x %= y - присваивание по модулю                a === b равно
                                                                   a !== b не равно
      строчный оператор конкатенации строк "+"  и "+="

29.Опишите преднозначение и принципы работы  с колекциями  Set & Map.
Ответ: Map  в отличии от Object в качестве ключа можно использовать любые типы данных. Даже 
(Object, NaN, ) у мепа довольно много разных методов которые упрощают работу с колекциями.
Set - обьект который хранит в себе только уникальные данные то есть они никогда не повторяются.
Элементы Set являются и ключами и значениями.
В структуре WeakMap ключами могут быть только обьекты! удобно работать с кешем и
 предотвращать утечки памяти.такойже принцип и у WeakSet.

 30.Что озночает глубокая(deep) и поверхнастная(shallow) копия обьекта? как зделать каждую из них?
 Ответ: Поверхностная копия обьекта осуществляется через Object.assign() или через деструктуирущего
 присваивания {...obj}.Поверхносно мы можем скопировать только свойства верхнего уровня,
 на вложенные обькты будет передоатся ссылка.Не копирует свойства из прототипа.
        Глубокая копия осуществляется через методы джейсона JSON.parse(JSON.stringify(mainObj))
Он копирует любые вложности, но проблема в том, что он не копирует методы обьекта
написанные пользователем(функции,свойство Symbol).
Для глубокого клонирования можно использовать метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.
 
 ============== Функции ==============

 31.Какая разница между декларативной функцией(function declaration) и 
 функциональным выражением(functoin expression)?
 Ответ: Функция обьявленная через function declaration создается интерпретатором
 до выполнения кода  поэтому их можно вызвать до обьявления.
 Примеры: декларативноя функциея   -  function declaration(){},
          функциональное выражение - const expression = function() {}

32.Что такое анонимная функция?
Ответ: Анонимная функция - функция без имени используется в колбеках, функциональных вырожениях
которое вызывается немедленно!

33.Расскажите про стралочные функции.В чем разница стелочных от обычных функций?
Ответ: Стрелочные функции имеют болле лаконичный  синтаксис. Как и функциональные выражения они
присваиваются переменным  или могут быть анонимными!Перед использованием стрелочной функции её 
необходимо создать заранееюСтрелочные функции не имеют своего this. В отличии от обычных 
функций, изменить значение this внутри стрелки после ее объявления нельзя.
Стрелочные функции не имеют своего this. В отличии от обычных функций, изменить 
значение this внутри стрелки после ее объявления нельзя.

34.Что такое и для чего используют IIFE(Immediately Invoked Function Expression)?
Ответ:Это паттерн.Немедленн вызываемое функциональное выражение.Хороша в создании облости видимости.
Любые переменные внутри IIFE не видимы для внешнего мира.
Они не только помогают организовывать и изображать ваш код в приятной и понятной манере, 
они также помогают сократить количество багов, избегая создания совершенно ненужных элементов 
глобальной области видимости.
const result = (function() {
    return "From IIFE";
}()); - может возвращать результат

35.Что такое hosting как он работает для переменных и функций?
Ответ:
 Поднятие переменных (hoisting) - это механизм интерпретатора, который, до фазы исполнения кода,
 поднимает объявления переменных в начало области видимости (блочной или функции)
 в которой они были объявлены. Хостинг поднимает функции обьявленными через function declaration!

36.Что такое замыкание(closure) и какие сценарии его использования?
Ответ: Замыкание это способ получения доступа и управления внешними переменными из функциии.
С помощью лексического окружения  функции и контекста выполнения её в стеке 
выполнения(это стек с принципом LIFO (Последний вошёл, первый вышел)).